requires 2.0.0

%alltop{
/*
 * Copyright © 2009  Red Hat, Inc. All rights reserved.
 * Copyright © 2009  Ding-Yi Chen <dchen at redhat.com>
 *
 * This file is part of the ibus-chewing Project.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
#include <stdlib.h>
#include <libintl.h>
#include <ibus.h>
#include <chewing.h>
#include <string.h>
#include <stdio.h>
#define GETTEXT_PACKAGE "gtk20"
#include <glib/gi18n.h>
#include <gtk/gtk.h>
#include <X11/extensions/XTest.h>
#include <X11/Xlib.h>
%}


enum CHEWING_KBTYPE{
    INVALID=-1,
    DEFAULT,
    HSU,
    IBM,
    GIN_YIEH,
    ETEN,
    ETEN26,
    DVORAK,
    DVORAK_HSU,
    DACHEN_CP26,
    HAN_YU
} Chewing:KbType;

enum CHEWING_MODIFIER_SYNC{
    DISABLE,
    FROM_KEYBOARD,
    FROM_IM
} Chewing:Modifier:Sync;

/**
 * ChewingInputMode:
 * @BYPASS: Do not handle key (Pure English mode)
 * @EDITING: Forming Chinese character (in pre-edit buffer).
 * @SELECTING: Selecting candidate.
 *
 */
enum CHEWING_INPUT_MODE{
    BYPASS,
    EDITING,
    SELECTING
} Chewing:Input:Mode;

%headertop{
#include "maker-dialog.h"
#define GCONF_KEY_PREFIX "/desktop/ibus/engine/Chewing/"
#define EASY_SYMBOL_INPUT_WORK_AROUND

extern PropertySpec propSpecs[];
extern const gchar *page_labels[];
extern const gchar *button_labels[];
extern GtkResponseType button_responses[];
#define ZHUYIN_BUFFER_SIZE 12
%}

%{
extern gboolean ibus_chewing_verbose;
//extern IBusConfig *iConfig;

#define G_DEBUG_MSG(level, msg, args...) if (level<=ibus_chewing_verbose) g_debug(msg, ##args)
#define IBUS_CHEWING_MAIN
#include "IBusChewingEngine-def.c"
%}

class IBus:Chewing:Engine from IBus:Engine{
    public ChewingContext *context=NULL
	destroywith chewing_delete;

    public Chewing:Modifier:Sync syncCapsLock_local=CHEWING_MODIFIER_SYNC_FROM_KEYBOARD;

    public GtkWidget *setting_dialog={
	GTK_WIDGET(maker_dialog_new_full(_("Setting"),3,page_labels,1,button_labels,button_responses))};

    protected gint selKeys[MAX_SELKEY];

    /* Plain Zhuyin mode */
    protected gboolean plainZhuyin=FALSE;

    protected ChewingInputMode inputMode=CHEWING_INPUT_MODE_BYPASS;

    /* For init work around */
    private gboolean initialized=FALSE;

    /* For easy symbol input work around */
    private gboolean easySymbolInput;

    protected IBusLookupTable *table=NULL
	destroy {
	    if (VAR) {
		ibus_lookup_table_clear(VAR);
		g_array_free(VAR->candidates,TRUE);
		g_free(VAR);
	    }
    };

    public IBusProperty    *chieng_prop={
        ibus_property_new("chewing_chieng_prop",PROP_TYPE_NORMAL,
		SELF_GET_CLASS(self)->chieng_prop_label_chi,
		NULL, NULL, TRUE, TRUE,
		PROP_STATE_UNCHECKED, NULL)
    };

    public IBusProperty    *alnumSize_prop={
        ibus_property_new("chewing_alnumSize_prop",PROP_TYPE_NORMAL,
	       	SELF_GET_CLASS(self)->alnumSize_prop_label_half,
	      	NULL, NULL, TRUE, TRUE,
		PROP_STATE_UNCHECKED, NULL);
    };

    public IBusProperty    *settings_prop={
	ibus_property_new("chewing_settings_prop",PROP_TYPE_TOGGLE,
	       	SELF_GET_CLASS(self)->settings_prop_label,
		PKGDATADIR "/icons/settings.png", NULL, TRUE, TRUE,
		PROP_STATE_UNCHECKED, NULL);
    };

    public IBusPropList   *prop_list={ibus_prop_list_new()};

    public IBusConfig *config=NULL;

    private Display *pDisplay = {XOpenDisplay( NULL )}
          destroywith XCloseDisplay;

    private guint key_last=0;
    private gchar zhuyin_latest[ZHUYIN_BUFFER_SIZE];

    classwide IBusText *chieng_prop_label_chi={ibus_text_new_from_static_string(_("Chi"))};
    classwide IBusText *chieng_prop_label_eng={ibus_text_new_from_static_string(_("Eng"))};

    classwide IBusText *alnumSize_prop_label_full={ibus_text_new_from_static_string(_("Full"))};
    classwide IBusText *alnumSize_prop_label_half={ibus_text_new_from_static_string(_("Half"))};

    classwide IBusText *settings_prop_label={ibus_text_new_from_static_string(_("Settings"))};

    init (self) {
          /* initialize the object here */
	G_DEBUG_MSG(2,"*** init()");
	if (!self->_priv->initialized){
	    maker_dialog_set_verbose_level(MAKER_DIALOG(self->setting_dialog),ibus_chewing_verbose);
	    gchar buf[100];
	    g_snprintf(buf,100,"%s/.chewing",getenv("HOME"));

	    chewing_Init(CHEWING_DATADIR, buf);

	    self->context=chewing_new();
	    chewing_set_ChiEngMode(self->context,CHINESE_MODE);
	    self->inputMode=CHEWING_INPUT_MODE_EDITING;

	    /* init properties */
	    ibus_prop_list_append(self->prop_list,self->chieng_prop);
	    ibus_prop_list_append(self->prop_list,self->alnumSize_prop);
	    ibus_prop_list_append(self->prop_list,self->settings_prop);

	    self->_priv->initialized=TRUE;
	}
    }

    private  void load_setting(self){
#define BUFFER_SIZE_LOCAL 200
	G_DEBUG_MSG(3,"*** load_setting()");
	int i;
	gchar buf[BUFFER_SIZE_LOCAL];
	GValue gValue={0};

	for (i=0; propSpecs[i].valueType!=G_TYPE_INVALID;i++){
	    G_DEBUG_MSG(4,"*** load_setting(), i=%d",i);
	    if (ibus_config_get_value(self->config, "engine/Chewing",propSpecs[i].key, &gValue)){
		switch(propSpecs[i].valueType){
		    case G_TYPE_BOOLEAN:
			buf[0]=(g_value_get_boolean(&gValue))? '1' : '0';
			buf[1]='\0';
			break;
		    case G_TYPE_UINT:
			g_snprintf(buf,BUFFER_SIZE_LOCAL,"%u",
				g_value_get_uint(&gValue));
			break;
		    case G_TYPE_INT:
			g_snprintf(buf,BUFFER_SIZE_LOCAL,"%d",
				g_value_get_int(&gValue));
			break;
		    case G_TYPE_STRING:
			g_strlcpy(buf,g_value_get_string(&gValue), BUFFER_SIZE_LOCAL);
			break;
		    default:
			break;

		}
	    }else{
		g_warning("%s /desktop/ibus/engine/Chewing/%s, %s %s",
			_("Warning: cannot load configure key"),
			propSpecs[i].key,
			(propSpecs[i].defaultValue)? _(" Use default value:") : _(" No default value, skipped.") ,
			(propSpecs[i].defaultValue)? propSpecs[i].defaultValue : ""
			);
		if (propSpecs[i].defaultValue){
		    g_strlcpy(buf,propSpecs[i].defaultValue, BUFFER_SIZE_LOCAL);
		}else{
		    continue;
		}
	    }
	    /* Add property to dialog */
	    maker_dialog_add_property(MAKER_DIALOG(self->setting_dialog),&propSpecs[i],buf,self);
	    maker_dialog_apply_widget_value(MAKER_DIALOG(self->setting_dialog),propSpecs[i].key);
	    g_value_unset(&gValue);
	}

	for (i=0; page_labels[i]!=NULL;i++){
	    maker_dialog_align_labels(MAKER_DIALOG(self->setting_dialog),page_labels[i],1.0f, 0.5f);
	}
	gtk_widget_hide(self->setting_dialog);
#undef BUFFER_SIZE_LOCAL
    }

    /* commit string */
    protected gboolean commit(self){
	gboolean commit=chewing_commit_Check(self->context);
	G_DEBUG_MSG(2,"*** commit() %s", (commit) ? "TRUE": "FALSE");
	if (commit){
	    gunichar *text=NULL;
	    IBusText *iText=NULL;
	    glong item_written;

	    gchar *commit_string=chewing_commit_String(self->context);
	    text=g_utf8_to_ucs4_fast(commit_string,-1, &item_written);
	    iText=ibus_text_new_from_ucs4(text);
	    ibus_engine_commit_text(IBUS_ENGINE(self),iText);
	    ibus_engine_update_lookup_table(IBUS_ENGINE(self),self->table,FALSE);
	    ibus_engine_hide_lookup_table(IBUS_ENGINE(self));
	    g_free(text);
	    g_free(commit_string);
	    g_object_unref(iText);
	    self->inputMode=CHEWING_INPUT_MODE_EDITING;
	}
	return commit;
    }

    private gunichar *make_preedit_string(self, glong *zhuyin_item_written_ptr,  glong *item_written_ptr){
	glong chiSymbol_item_written=0;
	gchar *str_ptr=chewing_buffer_String(self->context);
	G_DEBUG_MSG(3, "make_preedit_string(): chewing_buffer_String=%s",str_ptr);
	gunichar *chiSymbolBuf=g_utf8_to_ucs4_fast(str_ptr,-1, &chiSymbol_item_written);
	g_free(str_ptr);

	int chiSymbolCursor = chewing_cursor_Current(self->context);
	int zhuyinCount;
        int zhuyin_tone=-1;

	str_ptr=chewing_zuin_String(self->context,&zhuyinCount);
	int zhuyinLen=strlen(str_ptr);
	G_DEBUG_MSG(3, "make_preedit_string(): chewing_zuin_String=%s count=%d len=%d inputMode=%d",
		str_ptr,zhuyinCount,zhuyinLen,self->inputMode);

	if (zhuyinLen>0){
	    g_strlcpy(self->_priv->zhuyin_latest,str_ptr,ZHUYIN_BUFFER_SIZE);
	    self->inputMode=CHEWING_INPUT_MODE_EDITING;
	    zhuyin_tone=0;
	}else{
	    /* Character/Phrase is formed */
	    if (self->inputMode==CHEWING_INPUT_MODE_EDITING){
		/* One of the ending keys is inputted */
		zhuyin_tone=get_tone(chewing_get_KBType(self->context),self->_priv->key_last);
		add_tone(self->_priv->zhuyin_latest,zhuyin_tone);
		self->inputMode=CHEWING_INPUT_MODE_SELECTING;
		if (self->plainZhuyin){
		    chewing_handle_Down(self->context);
		}
	    }else if (self_is_selectKey(self, self->_priv->key_last)){
		/* In SELECTING mode */
		/* One of selection keys is pressed */
		self->_priv->zhuyin_latest[0]='\0';
		zhuyin_tone=-1;
		self->inputMode=CHEWING_INPUT_MODE_EDITING;
	    }
	}
	G_DEBUG_MSG(3, "make_preedit_string(): zhuyin_latest=%s zhuyin_tone=%d inputMode=%d",
		self->_priv->zhuyin_latest,zhuyin_tone,self->inputMode);
	gunichar *zhuyinBuf=g_utf8_to_ucs4_fast(str_ptr,-1, zhuyin_item_written_ptr);
	g_free(str_ptr);

	glong i;
	*item_written_ptr=chiSymbol_item_written+ *zhuyin_item_written_ptr;
	gunichar *preeditBuf=g_new(gunichar, *item_written_ptr+1);
	glong j=0;
	for (i=0;i<*item_written_ptr;i++){
	    if (i<chiSymbolCursor){
		preeditBuf[i]=chiSymbolBuf[i];
	    }else if (j<*zhuyin_item_written_ptr){
		/* Inserting zhuyinBuf */
		preeditBuf[i]=zhuyinBuf[j++];
	    }else{
		/* Append rest zhuyinBuf */
		preeditBuf[i]=chiSymbolBuf[i- *zhuyin_item_written_ptr];
	    }
	}
	preeditBuf[i]='\0';
	g_free(chiSymbolBuf);
	g_free(zhuyinBuf);
	return preeditBuf;
    }

    private void update_lookup_table(self){
	ibus_lookup_table_clear(self->table);
	int choicePerPage=chewing_cand_ChoicePerPage(self->context);
	int i=0;
	char *candidate=NULL;
	IBusText *iText=NULL;

	G_DEBUG_MSG(3,"*** update_lookup_table() TotalChoice=%d CurrentPage=%d",
		chewing_cand_TotalChoice(self->context),chewing_cand_CurrentPage(self->context));
	if (chewing_cand_TotalChoice(self->context) >0){
	    chewing_cand_Enumerate(self->context);
	    for(i=0;i<choicePerPage;i++){
		if (chewing_cand_hasNext(self->context)){
		    candidate=chewing_cand_String(self->context);
		    iText=ibus_text_new_from_string (candidate);
		    ibus_lookup_table_append_candidate(self->table,iText);
		    g_free(candidate);
		    g_object_unref (iText);
		}else{
		    break;
		}
	    }
	    ibus_engine_update_lookup_table(IBUS_ENGINE(self),self->table,TRUE);
	    ibus_engine_show_lookup_table(IBUS_ENGINE(self));
	}else{
	    ibus_engine_update_lookup_table(IBUS_ENGINE(self),self->table,FALSE);
	    ibus_engine_hide_lookup_table(IBUS_ENGINE(self));
	}
    }

    private void update_aux_string(self){
	IBusText *iText=NULL;
	gunichar *text=NULL;
	glong item_written;
	if (chewing_aux_Length(self->context)>0){
	    gchar *aux_string=chewing_aux_String(self->context);
	    text=g_utf8_to_ucs4_fast(aux_string,-1,&item_written);
	    iText=ibus_text_new_from_ucs4 (text);
	    ibus_engine_update_auxiliary_text(IBUS_ENGINE(self),iText,TRUE);
	    g_object_unref (iText);
	    ibus_engine_show_auxiliary_text(IBUS_ENGINE(self));
	    g_free(aux_string);
	    g_free(text);
	}else{
	    ibus_engine_hide_auxiliary_text(IBUS_ENGINE(self));
//            iText=ibus_text_new_from_string(self->_priv->zhuyin_latest);
//            ibus_engine_update_auxiliary_text(IBUS_ENGINE(self),iText,TRUE);
//            g_object_unref (iText);
//            ibus_engine_show_auxiliary_text(IBUS_ENGINE(self));
	}
    }

    private void update_preedit(self){
	glong zhuyin_item_written, item_written;
	gunichar *preeditBuf=self_make_preedit_string(self, &zhuyin_item_written, &item_written);
	IBusText *iText=ibus_text_new_from_ucs4(preeditBuf);
	int chiSymbolCursor = chewing_cursor_Current(self->context);
	ibus_text_append_attribute (iText, IBUS_ATTR_TYPE_FOREGROUND, 0x00ffffff,
		chiSymbolCursor, chiSymbolCursor+zhuyin_item_written);
	ibus_text_append_attribute (iText, IBUS_ATTR_TYPE_BACKGROUND, 0x00000000,
		chiSymbolCursor, chiSymbolCursor+zhuyin_item_written);

	IntervalType it;
	chewing_interval_Enumerate(self->context);
	while(chewing_interval_hasNext(self->context)){
	    chewing_interval_Get(self->context,&it);
	    ibus_text_append_attribute (iText, IBUS_ATTR_TYPE_UNDERLINE, IBUS_ATTR_UNDERLINE_DOUBLE,
		    it.from, it.to);
	}
	ibus_text_append_attribute (iText, IBUS_ATTR_TYPE_UNDERLINE, IBUS_ATTR_UNDERLINE_SINGLE,
		0, -1);
	ibus_engine_update_preedit_text (IBUS_ENGINE(self),iText, chiSymbolCursor, TRUE);
	g_object_unref (iText);
    }

    protected gboolean update(self){
	G_DEBUG_MSG(2,"*** update()");

	self_update_aux_string(self);
	self_update_preedit(self);
	G_DEBUG_MSG(3,"*** update() inputMode=%d",self->inputMode);
	self_update_lookup_table(self);
	self_commit(self);

	if (chewing_keystroke_CheckAbsorb(self->context))
	    return TRUE;
	if (chewing_keystroke_CheckIgnore(self->context))
	    return FALSE;
	return TRUE;
    }

    protected void refresh_property(self,const gchar  *prop_name){
	G_DEBUG_MSG(2,"*** refresh_property(%s)",prop_name);
	if (strcmp(prop_name,"chewing_chieng_prop")==0){
	    if (chewing_get_ChiEngMode(self->context)){
		/* Chinese  */
		ibus_property_set_label(self->chieng_prop,SELF_GET_CLASS(self)->chieng_prop_label_chi);
	    }else{
		/* English */
		ibus_property_set_label(self->chieng_prop,SELF_GET_CLASS(self)->chieng_prop_label_eng);
	    }
	    ibus_engine_update_property(IBUS_ENGINE(self),self->chieng_prop);
	}else if (strcmp(prop_name,"chewing_alnumSize_prop")==0){
	    if (chewing_get_ShapeMode(self->context)){
		/* Full-Sized Shape */
		ibus_property_set_label(self->alnumSize_prop,SELF_GET_CLASS(self)->alnumSize_prop_label_full);
	    }else{
		/* Half-Sized Shape */
		ibus_property_set_label(self->alnumSize_prop,SELF_GET_CLASS(self)->alnumSize_prop_label_half);
	    }
	    ibus_engine_update_property(IBUS_ENGINE(self),self->alnumSize_prop);
	}
    }

    /**
     * refresh_prop_list:
     * @self: this instances.
     *
     * Refresh the property list (language bar).
     */
    public void refresh_property_list(self){
	self_refresh_property(self,"chewing_chieng_prop");

	self_refresh_property(self,"chewing_alnumSize_prop");

	self_refresh_property(self,"chewing_settings_prop");
	ibus_engine_register_properties(IBUS_ENGINE(self),self->prop_list);
    }

    /**
     * save_config:
     * @self: this instances.
     * @key_suffix: key to be set.
     * @returns: TRUE if successful, FALSE otherwise.
     *
     * Save the property value to disk.
     */
    public gboolean save_config(self, const gchar *key_suffix){
	G_DEBUG_MSG(1,"*** save_config(%s,-)",key_suffix);
	GValue gValue={0};
	maker_dialog_get_widget_value(MAKER_DIALOG(self->setting_dialog),key_suffix,&gValue);
	return ibus_config_set_value (self->config,"engine/Chewing",key_suffix,&gValue);
    }

    /**
     * save_config_all:
     * @self: this instances.
     * @key_suffix: key to be set.
     * @returns: TRUE if all successful, FALSE otherwise.
     *
     * Save alll property values to disk.
     */
    public gboolean save_config_all(self){
	int i;
	gboolean success=TRUE;
	for(i=0;propSpecs[i].valueType!=G_TYPE_INVALID;i++){
	    if (!self_save_config(self,propSpecs[i].key)){
		success=FALSE;
	    }
	}
	return success;
    }

    protected gboolean is_selectKey(self, guint keyval){
	int j;
	for (j=0;j< MAX_SELKEY;j++){
	    if (self->selKeys[j]==keyval){
		return TRUE;
	    }
	}
	if (keyval==' ' && chewing_get_spaceAsSelection(self->context)){
	    return TRUE;
	}
	return FALSE;
    }

    protected void set_selKeys_string(self,const gchar* selKeys_str){
	int j;
	int len_min= MIN(strlen(selKeys_str), MAX_SELKEY);
	for (j=0;j< len_min;j++){
	    self->selKeys[j]=(int) selKeys_str[j];
	}
	chewing_set_selKey(self->context, self->selKeys,len_min);
    }

    private IBusProperty* get_iBusProperty(self, const gchar *prop_name){
	if (strcmp(prop_name,"chewing_chieng_prop")==0){
	    return self->chieng_prop;
	}else if (strcmp(prop_name,"chewing_alnumSize_prop")==0){
	    return self->alnumSize_prop;
	}else if (strcmp(prop_name,"chewing_settings_prop")==0){
	    return self->settings_prop;
	}
	G_DEBUG_MSG(2,"*** get_iBusProperty(%s): NULL is returned",prop_name);
	return NULL;
    }

    private void handle_Default(self, guint keyval, gboolean shiftPressed){
	G_DEBUG_MSG(2,"*** IBusChewingEngine::handle_Default(-,%u) plainZhuyin=%s inputMode=%d",
		keyval,(self->plainZhuyin)? "TRUE": "FALSE",self->inputMode);
#ifdef EASY_SYMBOL_INPUT_WORK_AROUND
	if (self->_priv->easySymbolInput){
	    /* If shift is pressed, turn on the  easySymbolInput, turn off
	     * otherwise
	     */
	    chewing_set_easySymbolInput(self->context,(shiftPressed)? 1:0);
	}
#endif
	chewing_handle_Default(self->context,keyval);
	if (self->plainZhuyin){
	    if (self_is_selectKey(self,self->_priv->key_last) &&
		    self->inputMode==CHEWING_INPUT_MODE_SELECTING){
		chewing_handle_Enter(self->context);
	    }
	}
    }

    private void force_commit(self){
	if (chewing_buffer_Check(self->context)){
	    if (!chewing_commit_Check(self->context)){
		chewing_handle_Enter(self->context);
	    }
	    self_update(self);
	}
    }

    /*============================================
     * Overridden Parent (IBusEngine) methods
     */

    override (IBus:Engine) void
    reset(IBus:Engine *engine){
	G_DEBUG_MSG(2,"*** reset 1");
	Self *self=SELF(engine);
	ibus_lookup_table_clear(self->table);
	chewing_Reset(self->context);
	ibus_engine_hide_auxiliary_text(IBUS_ENGINE(engine));
	ibus_engine_hide_lookup_table(IBUS_ENGINE(self));
    }


    override (IBus:Engine) gboolean
    process_key_event(IBus:Engine *engine, guint  keyval,  guint  modifiers){
	Self *self=SELF(engine);
	gboolean result=TRUE;
	if (modifiers & IBUS_RELEASE_MASK){
	    /* Skip release event */
	    return TRUE;
	}

	G_DEBUG_MSG(3,"*** process_key_event(-, %u(%s), %u) ... proceed.",keyval, keyName_get(keyval), modifiers);
	guint state= modifiers & (IBUS_SHIFT_MASK | IBUS_CONTROL_MASK | IBUS_MOD1_MASK);
	self->_priv->key_last=keyval;
	if (state==0){
	    switch (keyval){
		case IBUS_Return:
		case IBUS_KP_Enter:
		    chewing_handle_Enter(self->context);
		    break;
		case IBUS_Escape:
		    chewing_handle_Esc(self->context);
		    break;
		case IBUS_BackSpace:
		    chewing_handle_Backspace(self->context);
		    break;
		case IBUS_Delete:
		case IBUS_KP_Delete:
		    chewing_handle_Del(self->context);
		    break;
		case IBUS_space:
		case IBUS_KP_Space:
		    chewing_handle_Space(self->context);
		    break;
		case IBUS_Page_Up:
		case IBUS_KP_Page_Up:
		    IBUS_ENGINE_GET_CLASS(engine)->page_up(engine);
		    break;
		case IBUS_Page_Down:
		case IBUS_KP_Page_Down:
		    IBUS_ENGINE_GET_CLASS(engine)->page_down(engine);
		    break;
		case IBUS_Up:
		case IBUS_KP_Up:
		    IBUS_ENGINE_GET_CLASS(engine)->cursor_up(engine);
		    break;
		case IBUS_Down:
		case IBUS_KP_Down:
		    IBUS_ENGINE_GET_CLASS(engine)->cursor_down(engine);
		    break;
		case IBUS_Left:
		case IBUS_KP_Left:
		    chewing_handle_Left(self->context);
		    break;
		case IBUS_Right:
		case IBUS_KP_Right:
		    chewing_handle_Right(self->context);
		    break;
		case IBUS_Home:
		case IBUS_KP_Home:
		    chewing_handle_Home(self->context);
		    break;
		case IBUS_End:
		case IBUS_KP_End:
		    chewing_handle_End(self->context);
		    break;
		case IBUS_Tab:
		    chewing_handle_Tab(self->context);
		    break;
		case IBUS_Caps_Lock:
		    chewing_handle_Capslock(self->context);
		    self_refresh_property(self,"chewing_chieng_prop");
		    break;
		default:
		    self_handle_Default(self,keyval,FALSE);
		    break;
	    }
	}else if (state==IBUS_SHIFT_MASK){
	    switch(keyval){
		case IBUS_Shift_L:
		    chewing_handle_ShiftLeft(self->context);
		    break;
		case IBUS_Shift_R:
		    chewing_handle_ShiftRight(self->context);
		    break;
		case IBUS_space:
		case IBUS_KP_Space:
		    chewing_handle_ShiftSpace(self->context);
		    chewing_set_ShapeMode(self->context, !chewing_get_ShapeMode(self->context));
		    self_refresh_property(self,"chewing_alnumSize_prop");
		    break;
		default:
		    self_handle_Default(self,keyval,TRUE);
		    break;
	    }
	}else if (state==IBUS_CONTROL_MASK){
	    if (keyval>=IBUS_0 && keyval<=IBUS_9){
		chewing_handle_CtrlNum(self->context,keyval);
	    }else if (keyval==IBUS_v || keyval==IBUS_V){
		chewing_handle_Right(self->context);
	    }else{
		result=FALSE;
	    }

	}else{
	    result=FALSE;
	}
	if (!result){
	    return FALSE;
	}
	return self_update(self);
    }


    override (IBus:Engine) void
    page_up(IBus:Engine *engine){
	Self *self=SELF(engine);
	chewing_handle_PageUp(self->context);
	self_update(self);
    }


    override (IBus:Engine) void
    page_down(IBus:Engine *engine){
	Self *self=SELF(engine);
	chewing_handle_PageDown(self->context);
	self_update(self);
    }

    override (IBus:Engine) void
    cursor_up(IBus:Engine *engine){
	Self *self=SELF(engine);
	chewing_handle_Up(self->context);
	self_update(self);
    }

    override (IBus:Engine) void
    cursor_down(IBus:Engine *engine){
	Self *self=SELF(engine);
	chewing_handle_Down(self->context);
	self_update(self);
    }

    override (IBus:Engine) void
    enable(IBus:Engine  *engine){
	G_DEBUG_MSG(2,"*** enable");
        Self *self=SELF(engine);

        if (!self->config){

            /* connections_list is not avail in init, so we put it here */
	    GList  *connections_list=ibus_service_get_connections(IBUS_SERVICE(engine));
	    g_assert(connections_list);
	    g_assert(connections_list->data);
	    IBusConnection *iConnection=(IBusConnection *) connections_list->data;
	    self->config=ibus_config_new(iConnection);
	    self_load_setting(self);
        }
	self->inputMode=CHEWING_INPUT_MODE_EDITING;
    }

    override (IBus:Engine) void
    disable(IBus:Engine  *engine){
	G_DEBUG_MSG(2,"*** disable");
	Self *self=SELF(engine);
	self_force_commit(self);
	self->inputMode=CHEWING_INPUT_MODE_BYPASS;
    }

    override (IBus:Engine) void
    focus_in(IBus:Engine *engine){
	G_DEBUG_MSG(2,"*** focus_in");
	Self *self=SELF(engine);

	/* Sync Caps_Lock and ChiEngMode */
	guint modifiers=keyModifier_get(self->_priv->pDisplay);
	gint caps_is_lock=(modifiers & IBUS_LOCK_MASK)!=0;
	G_DEBUG_MSG(2,"focus_in(): ChiEng=%d IBUS_LOCK=%d",
		chewing_get_ChiEngMode(self->context),caps_is_lock);
	if (chewing_get_ChiEngMode(self->context)==caps_is_lock){
	    /* Caps_lock and ChiEngMode does not agree each other */
	    switch(self->syncCapsLock_local){
		case CHEWING_MODIFIER_SYNC_FROM_KEYBOARD:
		    chewing_set_ChiEngMode(self->context,!caps_is_lock);
		    break;
		case CHEWING_MODIFIER_SYNC_FROM_IM:
		    /* fake event won't go through process_key_event */
		    key_send_fake_event(IBUS_Caps_Lock,self->_priv->pDisplay);
		    break;
		default:
		    g_warning("Caps_lock and ChiEngMode does not agree each other!");
		    break;

	    }
	}
	self_refresh_property_list(self);
	self_update_preedit(self);
    }

    override (IBus:Engine) void
    focus_out(IBus:Engine *engine){
	Self *self=SELF(engine);
	G_DEBUG_MSG(2,"*** focus_out: buffer_Check %d",chewing_buffer_Check(self->context));
	self_force_commit(self);
    }

    override (IBus:Engine) void
    property_activate(IBus:Engine *engine, const gchar  *prop_name, guint  prop_state){
	G_DEBUG_MSG(2,"*** property_activate(-, %s, %u)", prop_name, prop_state);
	Self *self=SELF(engine);
	gboolean needRefresh=TRUE;
	if (strcmp(prop_name,"chewing_chieng_prop")==0){
	    /* Toggle Chinese <-> English */
	    chewing_set_ChiEngMode(self->context, !chewing_get_ChiEngMode(self->context));
	}else if (strcmp(prop_name,"chewing_alnumSize_prop")==0){
	    /* Toggle Full <-> Half */
	    chewing_set_ShapeMode(self->context, !chewing_get_ShapeMode(self->context));
	}else if (strcmp(prop_name,"chewing_settings_prop")==0){
	    if (self->settings_prop->state==PROP_STATE_UNCHECKED){
		if (gtk_dialog_run(GTK_DIALOG(self->setting_dialog))==GTK_RESPONSE_OK){
		    self_save_config_all(self);
		}
		gtk_widget_hide(self->setting_dialog);
		self->settings_prop->state=PROP_STATE_UNCHECKED;
	    }
	}else{
	    G_DEBUG_MSG(2,"*** property_activate(-, %s, %u) not recognized",prop_name, prop_state);
	    needRefresh=FALSE;
	}
	if (needRefresh)
	    self_refresh_property(self,prop_name);
    }

    override (IBus:Engine) void
    property_show(IBus:Engine *engine, const gchar  *prop_name){
	G_DEBUG_MSG(2,"*** property_show(-, %s)",prop_name);
	Self *self=SELF(engine);
	IBusProperty *prop=self_get_iBusProperty(self, prop_name);
	ibus_property_set_visible(prop,TRUE);
	ibus_engine_update_property(engine,prop);
    }

    override (IBus:Engine) void
    property_hide(IBus:Engine *engine, const gchar  *prop_name){
	G_DEBUG_MSG(2,"*** property_hide(-, %s)",prop_name);
	Self *self=SELF(engine);
	IBusProperty *prop=self_get_iBusProperty(self, prop_name);
	ibus_property_set_visible(prop,FALSE);
	ibus_engine_update_property(engine,prop);
    }
}
